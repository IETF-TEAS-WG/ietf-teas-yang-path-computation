module ietf-te-path-computation {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-te-path-computation";
  // replace with IANA namespace when assigned

  prefix "te-pc";

  import ietf-inet-types {
    prefix "inet";
  }

  import ietf-te {
    prefix "te";
  }

  import ietf-te-types {
    prefix "te-types";
  }

  organization
    "Traffic Engineering Architecture and Signaling (TEAS)
     Working Group";

  contact
    "WG Web:   <http://tools.ietf.org/wg/teas/>
     WG List:  <mailto:teas@ietf.org>

     WG Chair: Lou Berger
               <mailto:lberger@labn.net>

     WG Chair: Vishnu Pavan Beeram
               <mailto:vbeeram@juniper.net>

   ";

  description "YANG model for stateless TE path computation";

  revision "2020-06-03" {
    description
      "Initial revision";
    reference
      "draft-ietf-teas-yang-path-computation";
  }

  /*
   * Features
   */

  /*
   * Identities
   */

  identity svec-metric-type {
    description
      "Base identity for svec metric type";
  }

  identity svec-metric-cumul-te {
    base svec-metric-type;
    description
      "TE cumulative path metric";
  }

  identity svec-metric-cumul-igp {
    base svec-metric-type;
    description
      "IGP cumulative path metric";
  }

  identity svec-metric-cumul-hop {
    base svec-metric-type;
    description
      "Hop cumulative path metric";
  }

  identity svec-metric-aggregate-bandwidth-consumption {
    base svec-metric-type;
    description
      "Cumulative bandwith consumption of the set of
       synchronized paths";
  }

  identity svec-metric-load-of-the-most-loaded-link {
    base svec-metric-type;
    description
      "Load of the most loaded link";
  }

  identity tunnel-action-path-compute-delete {
    base te:tunnel-actions-type;
    description
      "Action type to delete the transient states
       of computed paths";
  }

  /*
   * Groupings
   */

  grouping protection-restoration-properties {
    description
      "This grouping defines the type of protection and restoration
       to be used by a requested path";
    leaf protection-type {
      type identityref {
        base te-types:lsp-protection-type;
      }
      default te-types:lsp-protection-unprotected;
      description "LSP protection type.";
    }
    leaf restoration-type {
      type identityref {
        base te-types:lsp-restoration-type;
      }
      default te-types:lsp-restoration-restore-any;
      description "LSP restoration type.";
    }
  }  // grouping protection-restoration-properties

  grouping requested-info {
    description
      "This grouping defines the information (e.g., metrics)
       which must be returned in the response";
    list requested-metrics {
      key 'metric-type';
      description
        "The list of the requested metrics
         The metrics listed here must be returned in the response.
         Returning other metrics in the response is optional.";
      leaf metric-type {
        type identityref {
          base te-types:path-metric-type;
        }
        description
          "The metric that must be returned in the response";
      }
    }
    leaf return-srlgs {
      type boolean;
      default false;
      description
        "If true, path srlgs must be returned in the response.
         If false, returning path srlgs in the response optional.";
    }
    leaf return-affinities {
      type boolean;
      default false;
      description
      "If true, path affinities must be returned in the response.
       If false, returning path affinities in the response is
       optional.";
    }
  }   // grouping requested-info

  grouping requested-state {
    description
      "Configuration for the transient state used
       to report the computed path";
    leaf timer {
      type uint16;
      units minutes;
      default 10;
      description
        "The timeout after which the transient state reporting
         the computed path should be removed.";
    }
    leaf transaction-id {
      type string;
      description
        "
         The transaction-id associated with this path computation
         to be used for fast deletion of the transient states
         associated with multiple path computations.

         This transaction-id can be used to explicitly delete all
         the transient states of all the computed paths associated
         with the same transaction-id.

         When one path associated with a transaction-id is setup,
         the transient states of all the other computed paths
         with the same transaction-id are automatically removed.

         If not specified, the transient state is removed only
         when the timer expires (when the timer is specified)
         or not created at all (stateless path computation,
         when the timer is not specified).
        ";
    }
  }   // grouping requested-state

  grouping reported-state {
    description
      "Information about the transient state created
       to report the computed path";

    leaf tunnel-ref {
      type te:tunnel-ref;
      description
        "
         Reference to the tunnel that reports the transient state
         of the computed path.

         If no transient state is created, this attribute is empty.
        ";
    }
    choice path {
      description
        "The transient state of the computed path can be reported
         as a primary, primary-reverse, secondary or
         a secondary-reverse path of a te-tunnel";
      case primary {
        leaf primary-path-ref {
          type leafref {
            path "/te:te/te:tunnels/" +
                 "te:tunnel[te:name=current()/../tunnel-ref]/" +
                 "te:primary-paths/te:primary-path/" +
                 "te:name";
          }
          must "../tunnel-ref" {
            description
              "The primary-path name can only be reported
               if also the tunnel name is reported.";
          }
          description
            "
             Reference to the primary-path that reports
             the transient state of the computed path.

             If no transient state is created,
             this attribute is empty.
            ";
        }
      } // case primary
      case primary-reverse {
        leaf primary-reverse-path-ref {
          type leafref {
            path "/te:te/te:tunnels/" +
                 "te:tunnel[te:name=current()/../tunnel-ref]/" +
                 "te:primary-paths/te:primary-path/" +
                 "te:name";
          }
          must "../tunnel-ref" {
            description
              "The primary-reverse-path name can only be reported
               if also the tunnel name is reported.";
          }
          description
            "
             Reference to the primary-reverse-path that reports
             the transient state of the computed path.

             If no transient state is created,
             this attribute is empty.
            ";
        }
      } // case primary-reverse
      case secondary {
        leaf secondary-path-ref {
          type leafref {
            path "/te:te/te:tunnels/" +
                 "te:tunnel[te:name=current()/../tunnel-ref]/" +
                 "te:secondary-paths/te:secondary-path/" +
                 "te:name";
          }
          must "../tunnel-ref" {
            description
              "The secondary-path name can only be reported
               if also the tunnel name is reported.";
          }
          description
            "
             Reference to the secondary-path that reports
             the transient state of the computed path.

             If no transient state is created,
             this attribute is empty.
            ";
        }
      } // case secondary
      case secondary-reverse {
        leaf secondary-reverse-path-ref {
          type leafref {
            path "/te:te/te:tunnels/" +
                 "te:tunnel[te:name=current()/../tunnel-ref]/" +
                 "te:secondary-reverse-paths/" +
                 "te:secondary-reverse-path/te:name";
          }
          must "../tunnel-ref" {
            description
              "The secondary-reverse-path name can only be reported
               if also the tunnel name is reported.";
          }
          description
            "
             Reference to the secondary-reverse-path that reports
             the transient state of the computed path.

             If no transient state is created,
             this attribute is empty.
            ";
        }
      } // case secondary
    }   // choice path
  }   // grouping reported-state

  grouping svec-metrics-bounds_config {
    description
      "TE path metric bounds grouping for computing a set of
       synchronized requests";
    leaf metric-type {
      type identityref {
        base svec-metric-type;
      }
      description "TE path metric type usable for computing a set of
         synchronized requests";
    }
    leaf upper-bound {
      type uint64;
      description "Upper bound on end-to-end svec path metric";
    }
  }   // grouping svec-metrics-bounds_config

  grouping svec-metrics-optimization_config {
    description
      "TE path metric bounds grouping for computing a set of
       synchronized requests";

    leaf metric-type {
      type identityref {
        base svec-metric-type;
      }
      description "TE path metric type usable for computing a set of
         synchronized requests";
    }
    leaf weight {
      type uint8;
      description "Metric normalization weight";
    }
  }   // grouping svec-metrics-optimization_config

  grouping svec-exclude {
    description "List of resources to be excluded by all the paths
      in the SVEC";
    container exclude-objects {
      description "resources to be excluded";
      list excludes {
        key index;
        ordered-by user;
        leaf index {
           type uint32;
           description "XRO subobject index";
        }
        description
          "List of explicit route objects to always exclude
           from synchronized path computation";
        uses te-types:explicit-route-hop;
      }
    }
  }   // grouping svec-exclude

  grouping synchronization-constraints {
    description "Global constraints applicable to synchronized
      path computation";
    container svec-constraints {
      description "global svec constraints";
      list path-metric-bound {
        key metric-type;
        description "list of bound metrics";
        uses svec-metrics-bounds_config;
      }
    }
    uses te-types:generic-path-srlgs;
    uses svec-exclude;
  }   // grouping synchronization-constraints

  grouping synchronization-optimization {
      description "Synchronized request optimization";
    container optimizations {
      description
        "The objective function container that includes attributes 
         to impose when computing a synchronized set of paths";

      choice algorithm {
        description "Optimizations algorithm.";
        case metric {
          if-feature te-types:path-optimization-metric;
          list optimization-metric {
            key "metric-type";
            description "svec path metric type";
            uses svec-metrics-optimization_config;
          }
        }
        case objective-function {
          if-feature te-types:path-optimization-objective-function;
          container objective-function {
            description
              "The objective function container that includes
               attributes to impose when computing a TE path";
            leaf objective-function-type {
              type identityref {
                base te-types:objective-function-type;
              }
              default te-types:of-minimize-cost-path;
              description "Objective function entry";
            }
          }
        }
      }
    }
  }   // grouping synchronization-optimization

  grouping synchronization-info {
    description "Information for sync";
    list synchronization {
      key "synchronization-id";
      description "sync list";
      leaf synchronization-id {
        type uint32;
        description "index";
      }
      container svec {
        description
         "Synchronization VECtor";
        leaf relaxable {
          type boolean;
          default true;
          description
           "If this leaf is true, path computation process is
            free to ignore svec content.
            Otherwise, it must take into account this svec.";
        }
        uses te-types:generic-path-disjointness;
        leaf-list request-id-number {
          type uint32;
          description
            "This list reports the set of path computation
             requests that must be synchronized.";
        }
      }
      uses synchronization-constraints;
      uses synchronization-optimization;
    }
  }   // grouping synchronization-info

  /*
   * These groupings should be removed when defined in te-types
   */

  grouping encoding-and-switching-type {
    description
      "Common grouping to define the LSP encoding and
       switching types";

    leaf encoding {
      type identityref {
        base te-types:lsp-encoding-types;
      }
      description "LSP encoding type";
      reference "RFC3945";
    }
    leaf switching-type {
      type identityref {
        base te-types:switching-capabilities;
      }
      description "LSP switching type";
      reference "RFC3945";
    }
  }

  grouping tunnel-common-attributes {
    description
      "Common grouping to define the TE tunnel parameters";

    uses encoding-and-switching-type;
    leaf source {
      type inet:ip-address;
      description "TE tunnel source address.";
    }
    leaf destination {
      type inet:ip-address;
      description "te-tunnel destination address";
    }
    leaf src-tp-id {
      type binary;
      description
        "TE tunnel source termination point identifier.";
    }
    leaf dst-tp-id {
      type binary;
      description
        "TE tunnel destination termination point identifier.";
    }
    leaf bidirectional {
      type boolean;
      default 'false';
      description "TE tunnel bidirectional";
    }
  }

  /*
   * AUGMENTS TO TE RPCs
   */

  augment "/te:tunnels-path-compute/te:input/te:path-compute-info" {
    description "Path Computation RPC input";
    list path-request {
      key "request-id";
      description "The list of the requested paths to be computed";
      leaf request-id {
        type uint32;
        mandatory true;
        description
          "Each path computation request is uniquely identified
           by the request-id-number.";
      }

      choice tunnel-attributes {
        default value;
        description
          "Whether the tunnel attributes are specified by value
           within this path computation request or by reference.
           The reference could be either to an existing te-tunnel
           or to an entry in the tunnel-attributes list";
        case reference {
          choice tunnel-exist {
            description
              "Whether the tunnel reference is to an existing
              te-tunnel or to an entry in the tunnel-attributes
              list";
            case tunnel-ref {
              leaf tunnel-ref {
                type te:tunnel-ref {
/*Open issue: should require-instance be false or true? */
                  require-instance false; 
                }              
                mandatory true;
                description "The referenced te-tunnel instance";
              }
            }   // case tunnel-ref
            case tunnel-attributes-ref {
              leaf tunnel-attributes-ref {
                type leafref {
                  path "/te:tunnels-path-compute/te:input/"
                     + "te:path-compute-info/"
                     + "te-pc:tunnel-attributes/te-pc:tunnel-name";
                }
/*
 * Open issue: RPC path
 
              leaf tunnel-attributes-ref {
                type leafref {
                  path "/te:tunnels-path-compute/"
                     + "te:path-compute-info/"
                     + "te-pc:tunnel-attributes/te-pc:tunnel-name";
                }
 */
                mandatory true;
                description "The referenced te-tunnel instance";
              }
            }   // case tunnel-attributes-ref 
          }   // choice tunnel-exist
          leaf path-name {
            type string;
            description "TE path name.";
          }
          choice tunnel-path-role {
            mandatory true;
            description
              "Whether this path is a primary, or a reverse primary,
               or a secondary, or a reverse secondary path";
            case primary-path {
              container primary-path {
                presence
                  "Indicates that the requested path
                   is a primary path";
                description "TE primary path";
                uses te:path-preference;
                uses te:k-requested-paths;
              }   // container primary-path
            }   // case primary-path
            case secondary-path {
              container secondary-path {
                description "TE secondary path";
                uses te:path-preference;
                uses protection-restoration-properties;
                list primary-path-ref {
                  key index;
                  min-elements 1;
                  description
                    "The list of primary paths that reference
                     this path as a candidate secondary path";
                  leaf index {
                    type uint32;
                    description
                    "The index used by the
                     primary-path-ref list";    
                  }
                  choice primary-path-exist {
                    description
                      "Whether the path reference is to an existing
                       te-tunnel path or to another path request";
                    case path-ref {
                      leaf primary-path-ref {
                        type leafref {
                          path "/te:te/te:tunnels/te:tunnel[te:name"
                             + "=current()/../../../tunnel-ref]/"
                             + "te:primary-paths/te:primary-path/"
                             + "te:name";
/* Open issue: should require-instance be false or true? */
                          require-instance false;
                        }
                        must "../../../tunnel-ref" {
                          description
                            "The primary-path can be referenced
                             if also the tunnel is referenced.";
                        }
                        mandatory true;
                        description "The referenced primary path";
                      }
                    }   // case path-ref
                    case path-request-ref {
                      leaf path-request-ref {
                        type leafref {
                          path "/te:tunnels-path-compute/te:input/"
                             + "te:path-compute-info/"
                             + "te-pc:path-request/"
                             + "te-pc:request-id";
                        }
/*
 * Open issue: RPC path
 
                      leaf path-request-ref {
                        type leafref {
                          path "/te:tunnels-path-compute/"
                             + "te:path-compute-info/"
                             + "te-pc:path-request/"
                             + "te-pc:request-id";
                        }
 */
                        mandatory true;
                        description
                          "The referenced primary path request";
                      }
                    }   // case path-request-ref 
                  }   // choice primary-path-exist
                }   // list primary-path-ref
              }   // container secondary-path
            }  // case secondary-path
            case primary-reverse-path {
              container primary-reverse-path {
                description "TE primary reverse path";
                choice primary-path-exist {
                  description
                    "Whether the path reference to the primary paths
                     for which this path is the reverse-path is to
                     an existing te-tunnel path or to another path
                     request";
                  case path-ref {
                    leaf primary-path-ref {
                      type leafref {
                        path "/te:te/te:tunnels/te:tunnel[te:name"
                           + "=current()/../../tunnel-ref]/"
                           + "te:primary-paths/te:primary-path/"
                           + "te:name";
/* Open issue: should require-instance be false or true? */
                        require-instance false;
                      }
                      must "../../tunnel-ref" {
                        description
                          "The primary-path can be referenced
                           if also the tunnel is referenced.";
                      }                      
                      mandatory true;
                      description "The referenced primary path";
                    }
                  }   // case path-ref
                  case path-request-ref {
                    leaf path-request-ref {
                      type leafref {
                        path "/te:tunnels-path-compute/te:input/"
                           + "te:path-compute-info/"
                           + "te-pc:path-request/"
                           + "te-pc:request-id";
                      }
/*
 * Open issue: RPC path
 
                    leaf path-request-ref {
                      type leafref {
                        path "/te:tunnels-path-compute/"
                           + "te:path-compute-info/"
                           + "te-pc:path-request/"
                           + "te-pc:request-id";
                      }
 */
                      mandatory true;
                      description
                        "The referenced primary path request";
                    }
                  }   // case path-request-ref 
                }   // choice primary-path-exist
              }   // container primary-reverse-path
            }   // case primary-reverse-path
            case secondary-reverse-path {
              container secondary-reverse-path {
                description "TE secondary reverse path";
                uses te:path-preference;
                uses protection-restoration-properties;
                list primary-reverse-path-ref {
                  key index;
                  min-elements 1;
                  description
                    "The list of primary reverse paths that
                     reference this path as a candidate
                     secondary reverse path";                  
                  leaf index {
                    type uint32;
                    description
                      "The index used by the
                       primary-reverse-path-ref list";
                  }
                  choice primary-reverse-path-exist {
                    description
                      "Whether the path reference is to an existing
                       te-tunnel path or to another path request";
                    case path-ref {
                      leaf primary-path-ref {
                        type leafref {
                          path "/te:te/te:tunnels/te:tunnel[te:name"
                             + "=current()/../../../tunnel-ref]/"
                             + "te:primary-paths/te:primary-path/"
                             + "te:name";
/* Open issue: should require-instance be false or true? */
                          require-instance false;
                        }
                        must "../../../tunnel-ref" {
                          description
                            "The primary-path can be referenced
                             if also the tunnel is referenced.";
                        }                        
                        mandatory true;
                        description
                          "The referenced primary path";
                      }
                    }   // case path-ref
                    case path-request-ref {
                      leaf path-request-ref {
                        type leafref {
                          path "/te:tunnels-path-compute/te:input/"
                             + "te:path-compute-info/"
                             + "te-pc:path-request/"
                             + "te-pc:request-id";
                        }
/*
 * Open issue: RPC path
 
                      leaf path-request-ref {
                        type leafref {
                          path "/te:tunnels-path-compute/"
                             + "te:path-compute-info/"
                             + "te-pc:path-request/"
                             + "te-pc:request-id";
                        }
 */ 
                        mandatory true;
                        description
                          "The referenced primary reverse path
                           request";
                      }
                    }   // case path-request-ref 
                  }   // choice primary-reverse-path-exist
                }   // list primary-reverse-path-ref
              }   // container secondary-reverse-path
            }   // case secondary-reverse-path
          }   // choice tunnel-path-role
        }   // case reference
        case value {
          leaf tunnel-name {
            type string; 
            description "TE tunnel name.";
          }
          choice path-role {
            default primary-path;
            description
              "Whether this path is a primary or a secondary path";
            case primary-path {
              leaf primary-path-name {
                type string;
                description "TE path name.";
              }
            }   // case primary-path
            case secondary-path {
              leaf secondary-path-name {
                type string;
                description "TE path name.";
              }
            }  // case secondary-path
          }   // choice path-role
/* 
 * Open issue: should protection-restoration-properties be moved
 *             under secondary-path?
 */
          uses te:k-requested-paths;
          uses protection-restoration-properties;
          uses tunnel-common-attributes;
          uses te-types:te-topology-identifier;
        }   // case value
      }   // choice tunnel-attributes
      uses te:path-compute-info;
      uses requested-info;
      container requested-state {
        presence
          "Request temporary reporting of the computed path state";
        description
          "Configures attributes for the temporary reporting of the
           computed path state (e.g., expiration timer).";
        uses requested-state;
      }   // container requested-state
    }   // list path-request
    list tunnel-attributes {
      key "tunnel-name";
      description
        "Tunnel attributes common to multiple request paths";
      leaf tunnel-name {
        type string; 
        description "TE tunnel name.";
      }
      uses tunnel-common-attributes;
      uses te:tunnel-associations-properties;
      uses protection-restoration-properties;
      uses te-types:tunnel-constraints;
      uses te:tunnel-hierarchy-properties {
        augment "hierarchy/dependency-tunnels" {
          description
            "Augment with the list of dependency tunnel requests.";
          list dependency-tunnel-request {
            key "name";
            description
              "A tunnel request entry that this tunnel request can
               potentially depend on.";
            leaf name {
              type leafref {
                path "/te:tunnels-path-compute/te:input/"
                   + "te:path-compute-info/te-pc:tunnel-attributes/"
                   + "te-pc:tunnel-name";
                }
/*
 * Open issue: RPC path
 
            leaf name {
              type leafref {
                path "/te:tunnels-path-compute/"
                   + "te:path-compute-info/te-pc:tunnel-attributes/"
                   + "te-pc:tunnel-name";
                }
 */
              description
                "Dependency tunnel request name.";
            }
            uses encoding-and-switching-type;
          }  // list dependency-tunnel-request
        }
      }
    }  // list tunnel-attributes
    uses synchronization-info;
  }   // path-compute rpc input

  augment "/te:tunnels-path-compute/te:output/"
        + "te:path-compute-result" {
    description "Path Computation RPC output";
    list response {
      key "response-id";
      config false;
      description "response";
      leaf response-id {
        type uint32;
        description
          "The response-id has the same value of the
           corresponding request-id.";
      }
      uses te:path-computation-response;
      uses reported-state;
    }
  }   // path-compute rpc output

  augment "/te:tunnels-actions/te:input/te:tunnel-info/"
        + "te:filter-type" {
    description "Augment Tunnels Action RPC input filter types";

    case path-compute-transactions {
      when "derived-from-or-self(../te:action-info/te:action, "
         + "'tunnel-action-path-compute-delete')";
      description "Path Delete Action RPC";
      leaf-list path-compute-transaction-id {
        type string;
        description
          "The list of the transaction-id values of the
           transient states to be deleted";
      }
    }   // case path-compute-transactions
  }   // path-delete rpc input

  augment "/te:tunnels-actions/te:output" {
    description
      "Augment Tunnels Action RPC input with path delete result";
    
    container path-computed-delete-result {
/*
 * Open issue: RPC path

 */
      when "derived-from-or-self(../../te:input/te:action-info/"
         + "te:action, 'tunnel-action-path-compute-delete')";
      description "Path Delete RPC output";
      leaf-list path-compute-transaction-id {
        type string;
        description
          "The list of the transaction-id values of the
           transient states that have been successfully deleted";
      }
    }   // container path-computed-delete-result
  }   // path-delete rpc output
}
